package ui

import (
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	"github.com/unkn0wn-root/resterm/internal/ui/scroll"
)

// enhancedData holds all enhanced UI state for the extensions.
// This keeps enhanced data separate from the core Model struct.
type enhancedData struct {
	requestSpinner       spinner.Model
	lastEditorCursorLine int
}

// InstallEnhanced sets up all enhanced UI features.
// Call this from main after creating the model to enable enhanced features.
func InstallEnhanced(m *Model) {
	data := &enhancedData{
		requestSpinner: createRequestSpinner(),
	}

	ext := &Extensions{
		Data: data,
		Hooks: &ExtensionHooks{
			OnUpdate:                   onUpdate,
			OnRequestStart:             onRequestStart,
			OnRequestEnd:               onRequestEnd,
			StatusBarExtras:            statusBarExtras,
			HandleCustomKey:            handleCustomKey,
			OnNavigatorSelectionChange: onNavigatorSelectionChange,
		},
	}

	m.SetExtensions(ext)

	// Hide editor by default
	m.editorCollapsed = true

	// Install typewriter mode scroll override
	scroll.AlignOverride = typewriterScrollAlign
}

// typewriterScrollAlign implements true typewriter mode scrolling.
// The cursor stays centered in the viewport (at h/2) whenever possible.
func typewriterScrollAlign(sel, off, h, total int) (offset int, override bool) {
	if h <= 0 || total <= 0 {
		return 0, false
	}
	if sel < 0 {
		sel = 0
	}
	if sel >= total {
		sel = total - 1
	}
	if h > total {
		h = total
	}
	maxOff := total - h
	if maxOff < 0 {
		maxOff = 0
	}

	// Typewriter mode: keep cursor centered
	center := h / 2
	targetOff := sel - center

	// Clamp to valid range
	if targetOff < 0 {
		targetOff = 0
	}
	if targetOff > maxOff {
		targetOff = maxOff
	}

	return targetOff, true
}

// createRequestSpinner initializes the spinner used during request execution.
func createRequestSpinner() spinner.Model {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("205"))
	return s
}

// getEnhancedData safely retrieves the enhanced extension data from the model.
func getEnhancedData(m *Model) *enhancedData {
	ext := m.GetExtensions()
	if ext == nil || ext.Data == nil {
		return nil
	}
	data, ok := ext.Data.(*enhancedData)
	if !ok {
		return nil
	}
	return data
}

// onUpdate handles spinner animation during request execution.
func onUpdate(m *Model, msg tea.Msg) tea.Cmd {
	data := getEnhancedData(m)
	if data == nil || !m.sending {
		return nil
	}

	// Update spinner animation
	var cmd tea.Cmd
	data.requestSpinner, cmd = data.requestSpinner.Update(msg)
	return cmd
}

// onRequestStart is called when a request begins executing.
// Returns the spinner tick command to start animation.
func onRequestStart(m *Model) tea.Cmd {
	data := getEnhancedData(m)
	if data == nil {
		return nil
	}

	// Start spinner animation
	return data.requestSpinner.Tick
}

// onRequestEnd is called when a request completes.
func onRequestEnd(m *Model) tea.Cmd {
	// Cleanup if needed
	return nil
}

// statusBarExtras adds enhanced items to the status bar.
func statusBarExtras(m *Model) []string {
	data := getEnhancedData(m)
	if data == nil {
		return nil
	}

	var extras []string

	// Show spinner when request is in progress
	if m.sending {
		spinnerText := data.requestSpinner.View() + " Sending request"
		extras = append(extras, spinnerText)
	}

	return extras
}

// onNavigatorSelectionChange is called when the navigator selection changes.
// This implements Navigation â†’ Editor sync: when navigating requests,
// the editor scrolls to show the selected request (only if editor is visible).
func onNavigatorSelectionChange(m *Model) {
	// Only sync if editor is visible (not collapsed)
	if m.collapseState(paneRegionEditor) {
		return
	}

	// Get the current active request
	req := m.currentRequest
	if req == nil {
		return
	}

	// Scroll editor to show the request
	m.revealRequestInEditor(req)
}

// handleCustomKey handles enhanced key bindings.
// Returns true if the key was handled.
func handleCustomKey(m *Model, key string) (bool, tea.Cmd) {
	switch key {
	case "r":
		// 'r' = reveal editor and focus it
		// If collapsed: expand it first, then focus
		// If already visible: just focus it
		var cmds []tea.Cmd
		if m.collapseState(paneRegionEditor) {
			// Editor is collapsed, so expand it
			if cmd := m.togglePaneCollapse(paneRegionEditor); cmd != nil {
				cmds = append(cmds, cmd)
			}
		}
		// Set focus to editor (whether it was collapsed or already visible)
		if cmd := m.setFocus(focusEditor); cmd != nil {
			cmds = append(cmds, cmd)
		}
		if len(cmds) > 0 {
			return true, tea.Batch(cmds...)
		}
		return true, nil
	case "right":
		// Right arrow = reveal editor and focus it when in navigator
		// This prevents conflict with navigator's right arrow usage
		if m.focus == focusRequests || m.focus == focusFile || m.focus == focusWorkflows {
			var cmds []tea.Cmd
			if m.collapseState(paneRegionEditor) {
				// Editor is collapsed, so expand it
				if cmd := m.togglePaneCollapse(paneRegionEditor); cmd != nil {
					cmds = append(cmds, cmd)
				}
			}
			// Set focus to editor (whether it was collapsed or already visible)
			if cmd := m.setFocus(focusEditor); cmd != nil {
				cmds = append(cmds, cmd)
			}
			if len(cmds) > 0 {
				return true, tea.Batch(cmds...)
			}
			return true, nil
		}
	case "q":
		// 'q' = quit/hide editor (collapse it using the existing collapse system)
		// Only when editor is focused
		if m.focus == focusEditor && !m.collapseState(paneRegionEditor) {
			// Editor is visible and focused, so collapse it and move focus to requests
			var cmds []tea.Cmd
			if cmd := m.togglePaneCollapse(paneRegionEditor); cmd != nil {
				cmds = append(cmds, cmd)
			}
			if cmd := m.setFocus(focusRequests); cmd != nil {
				cmds = append(cmds, cmd)
			}
			if len(cmds) > 0 {
				return true, tea.Batch(cmds...)
			}
			return true, nil
		}
	}

	return false, nil
}

// GetLastEditorCursorLine returns the last tracked editor cursor line.
func GetLastEditorCursorLine(m *Model) int {
	data := getEnhancedData(m)
	if data == nil {
		return 0
	}
	return data.lastEditorCursorLine
}

// SetLastEditorCursorLine updates the last tracked editor cursor line.
func SetLastEditorCursorLine(m *Model, line int) {
	data := getEnhancedData(m)
	if data == nil {
		return
	}
	data.lastEditorCursorLine = line
}
